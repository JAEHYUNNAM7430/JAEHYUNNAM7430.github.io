## 1. ABSTRACT CLASS

안녕하세요. ! MONKEY.D 입니다 :-) 

abstract는 한국어로는 추상으로 번역이 됩니다. 저번 시간에 배웠던 접근 제어자와 같이 상속을 강제하는 규칙이라고 생각하시고 저를 따라오시면 됩니다!

클래스? 추상 클래스? 차이가 뭘까??

요약을 하자면,  A클래스, B클래스, C클래스가 있다고 가정을 합니다.  각 클래스 안에는 각자의 필드 and 메서드가 있을것입니다. 

> 추상클래스는 A클래스, B클래스, C클래스들 간에 비슷한 필드와 메서드를 공통적으로 추출해 만들어진 클래스입니다.

아직은 감이 안올것 같습니다.

예를 들자면 '이어폰'이라는 클래스가 있습니다. '이어폰'을 만드는 제조사는 여러개입니다.  Apple, Samsung, LG로 예를 들어보자면 각 제조사만의 스타일대로 이어폰을 제작하며 출시를 합니다. 여기서 Apple 제조사는 에어팟을 두번 두드리면 노래 재생이 됩니다. Samsung 제조사의 버즈는 블루투스 연결하고 휴대폰에서 노래 재생버튼을 누르면 재생이 됩니다. LG제조사는 이어폰잭을 연결시키고 노래재생 버튼을 누르면 노래재생이 됩니다(예일뿐 기능좋은 LG도 기능좋은 이어폰 많습니다..ㅎㅎ) 여기서 이 이어폰들 간에 공통점은?? (모르면 몽키킥!!) 바로 노래를 재생한다 라는 액션! 즉 ***<u>메서드(기능)가 공통적</u>*** 입니다. 그럼 이 메서드를 추출하여 추상클래스 안에 넣어두면 됩니다.

(이어폰을 상속받아 탄생한, Apple,Samsung,LG 이어폰)

다른 예를 들어 보겠습니다. 제가 좋아하는 강아지로 예를들어보겠습니다. 비숑이라는 강아지와 포메라니안이라는 강아지가 있습니다. 여기서 강아지는 일반적으로 다리 4개, 귀 2개, 눈 2개, 입 1개 , 코 1개를 가지고 있습니다. 

느낌이 오나요? **공통적인 변수**입니다. 왼쪽 눈, 오른쪽 눈, 왼쪽 귀, 오른쪽 귀, 입, 코,왼쪽 앞다리 등 이 변수들을 추상클래스에 넣어버립니다.

다음으론 포메라니안과 비숑이 짖고있습니다. 강아지는 공통적으로는 짖고 있지만 포메라니안은 짖을 때 송곳니가 보이지만, 비숑은 혀를 내밀으면서 짖습니다. 각자 다른 방식으로 짖고 있습니다. 하지만 포메라니안과, 비숑은 공통적으로 짖는 액션을 하고 있습니다. 이것은 공통적인 메서드 입니다. 따라서 추상클래스에 해당 메서드를 넣어줍니다.  

(강아지를 상속받아 탄생한, '비숑'이라는 클래스, '포메라니안'이라는 클래스) 

느낌이 오시나요? **실체클래스는 실체가 드러나는 클래스입니다. 추상클래스는 실체 클래스의 공통적인 부분을 추출해 어느정도 규격을 잡아놓은 추상적인 클래스입니다. 그래서 실체클래스 실제 객체를 생성할 정도의 구체성을 가지는 반면! 추상클래스는 아직 메서드와 내용이 추상적이기 때문에 객체를 생성할 수 없게 만들었습니다.**

객체를 직접 생성할 수 있는 클래스를 실체클래스라고 하는데, 실체클래스들의 공통적인 특성을 추출해서 선언한 클래스를 추상클래스라고 합니다. 여기서 **추상클래스와 실체클래스는 상속적인 관계**를 가지고 있습니다.

포인트 3개는 꼭 짚고 갑시다!

 {: .notice--warning} 

**1. 추상클래스는 뭐? 실체클래스의 공통적인 부분(변수,메서드)를 추출해서 선언한 클래스**

**2. 추상클래스는 객체를 생성할 수 없다! 아직은 실체성이 없고 구체적이지 않기 때문에!**

**3. 추상클래스와 실체클래스는 어떤관계? 상속관계!**



## 2. 추상클래스의 용도

대체 추상클래스는 왜 사용하는 것일까요?? 그 이유는 3가지로 나눠볼 수 있습니다. 따라와보세요!

#### **1. 공통 필드와 메서드를 통일시킬 목적으로!**

<u>5명의 개발자에게 핸드폰을 상속받아 각자의 실체클래스를 구현하라고 명령을 내려봅시다! (상상을 해봅시다.)</u>

상식적으로 5명의 개발자가 과연 전부 똑같은 실체클래스를 구현할까요? **절대 아닙니다!!!**

5명의 개발자가 생각한 변수명, 메서드명은 각각의 다른 이름을 가지고 구현될 것입니다. 이렇게 구현이 되면 문제가 있습니다. 만약, 수천줄에 이르는 코드에 A라는 핸드폰 실체 클래스 객체를 선언하고 해당 객체의 필드와 메서드를 작성했다 가정해봅시다. 그런데, A핸드폰이 망가져서, B핸드폰으로 교체해야한다고 가정을 해봅시다! 그러면 어떠한 문제가 발생할까요?

B핸드폰의 변수와 메서드명이 A핸드폰과 동일하다면 객체 인스턴스만 변경하면 되지만, 5명의 개발자가 구현한 클래스들의 변수명, 메서드명은 다르기 때문에 필드와 메서드를 전부 다 확인해서 변경해줘야 합니다. <u>유지보수는 하지 못할 망정 아예 새로 개발해야 하는 것이나 마찬가지입니다. 이 것을 해결할 방법이 바로 추상클래스 입니다.</u> 

즉, 추상클래스에서 미리 정의한 필드와 메서드가 있다면, 실체클래스는 추상클래스의 필드와 메서드명을 변경할 수 없고, 무조건 해당 명으로 구현해야 합니다! **따라서, 필드와 메서드 이름을 통일시켜 유지보수성의 향상과 통일성의 유지를 할 수 있는 일석이조의 효과를 가질 수 있습니다.**



#### **2. 실체클래스 구현시, 시간절약**

실무적으로 생각을 해봅시다!(상상에 들어갑시다 레드썬!)

나는 SI개발자라고 최면을 걸어봅시다. 선배님이 자동차라는 엄청난 클래스를 3일안에 구현하라고 합니다.(너무한 선배님..) 

그럼 설계부터 생각을 해야합니다. 자동차는 바퀴, 백미러, 창문, 트렁크, 등등 ...

느낌이 오나요? 여기서 추상클래스가 효과를 발휘합니다. 내가 자동차를 구현해야 하는데, 자동차 추상클래스를 상속받으면, 자연스럽게 자동차에 공통적으로 들어가야하는 필드와 메서드가 녹여져 있는 필드와 메서드가 오버라이딩 됩니다. 

**--->즉, 강제로 주어지는 필드와 메서드를 가지고 나만의 스타일대로 구현만 하면 됩니다. 때문에 설계 시간이 절약되어 구현하는 것에 집중할 수 있습니다!**

#### **3. 규격에 맞는 실체클래스 구현**

위에 있는 (2.실체클래스 구현시, 시간절약) 과 비슷할 수도 있는 내용입니다. 하지만 따로 분류하여 설명해야 될 것 같아 굳이 규격에 맞는 실체클래스 구현이라고 했습니다. 이미 설명했지만, 아무리 자기 스타일대로 클래스를 구현하다고 해도 그것도 결국엔 규격안에서 구현하는 것을 허락한다는 것이지, 규격도 없이 아무렇게나 구현을 해서는 안됩니다. 왜냐면 혼자서 개발을 하는 것이 아닙니다. 모두가 약속한 필드와 메서드 그리고 설계 규칙에 녹아져 있는 규격에 맞는 클래스를 구현해야 합니다. 그래야 코드 수정시에, 영향도는 최소화 시키며 유지보수성은 최대화 시킬수 있습니다.

여기서 추상클래스의 강력한 기능이 나옵니다. 추상클래스를 상속받은 실체클래스들은 반드시!! 추상메서드를 재정의(오버라이딩)해서 실행 내용을 작성해야 합니다. 만약 그렇지 않으면 컴파일 에러를 발생시켜 실행조차 못하게 막습니다. 따라서, 코더들은 강제적으로 추상메서드를 구현해야합니다. 여기서 추상메서드라는 것이 갑자기 나왔는데, 추상클래스 안에 abstract 키워드를 가지고 있는 메서드는 추상메서드라고 하고, 상속시 반드시 재정의해야하는 메서드라는 뜻입니다!

**중요한건, 소스 수정시 다른 소스의 영향도를 적게 가져가면서 변화에는 유연하게 만들기 위해 추상클래스를 사용하기도 합니다. 규격에 맞게 소스가 구현되어 있기 때문에 해당 규격에 대한 구현부만 수정하면 손 쉽게 수정이 가능하기 때문입니다.**



## 3. 추상클래스 문법

문법을 알아봅시다! 되게 간단합니다. 

클래스 앞에 abstract 키워드만 붙혀주면 추상클래스입니다.

```java
public **abstract** class 클래스명{

 //필드

 //생성자

 //메서드

 //추상메서드

 

}
```

추상메서드도 메서드 리턴타입 앞에 abstract 키워드를 붙이면 됩니다.

```java
[ public | protected ] **abstract** 리턴타입 메소드명(매개변수1, 매개변수2, ... );
```

자 이제, 실제 예제를 통해 코드를 살펴볼까요?

```java
package ABSTRACTCLASS;

public abstract class Animal {
    public String kind;
    
    public void breath(){
        System.out.println("숨을 쉰다.");
    }
    //추상메서드
    public abstract void sound();//구체적인 구현부는 없습니다.
}
```

Animal이라는 추상클래스를 구현했습니다. 

<u>Animal 클래스 앞에 abstract가 있기 때문에 해당 클래스는 추상클래스임을 알 수 있습니다.</u> 추상클래스 내부를 보면 kind필드와 breath()라는 일반 메서드, 그리고 abstract 키워드를 붙인 sound() 추상메서드가 있습니다. **여기서 해당 추상클래스를 상속받는 실체클래스들은 반드시 sound()라는 추상메서드를 상속받아 재정의(오버라이딩)해야합니다.**

```java
package ABSTRACTCLASS;

public class Dog extends Animal{
    public Dog(){
        this.kind = "포유류";
    }
    @Override
    public void sound() {
        // TODO Auto-generated method stub
        System.out.println("왈왈!");
    }
}
```

extends 키워드를 통해, Animal 추상클래스를 상속받은 Dog 실체클래스입니다.  필드는 추상클래스 필드를 그대로 사용했고, sound() 추상메서드를 오버라이딩해서 구현했음을 알 수 있습니다. 명확하게 @Override 어노테이션도 해당 메서드가 재정의 되었음을 알 수 있습니다.

 

```java
package ABSTRACTCLASS;
public class Cat extends Animal{
    public Cat(){
        this.kind = "포유류";
    }
    @Override
    public void sound() {
        // TODO Auto-generated method stub
        System.out.println("야옹");
    }}
```

Dog 실체클래스와 똑같습니다. 다만!! **sound() 추상메서드는 Cat실체클래스에 맞게끔 자기스타일대로 구현되어있음을 확인할 수 있습니다. 여기서 오버라이딩을 하면, 다형성이 발생된다는 사실을 알 수 있습니다.** **또한, 규격에 맞게끔 필드명과 메서드명이 통일되어 있음을 알 수 있고, 실체클래스들의 코드를 보면 모양은 비슷비슷합니다. 즉, 규격이 맞춰져 있다는 뜻입니다.**

 

*다형성 : 같은 기능인데, 다른 결과를 도출할 수 있다.



```java
package ABSTRACTCLASS; 
public class AnimalExample {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Dog dog = new Dog(); 
        Cat cat = new Cat(); 
        
        dog.sound();
        cat.sound();
        
        Animal animal = null;
        
        animal = new Dog();//자동 타입변환
        animal.sound();//Dog에 구현된 Sound()메서드 실행
        
        animal = new Cat();//자동 타입변환
        animal.sound();//Cat에 구현된 Sound()메서드 실행
        
        animalSound(new Dog());//자동 타입변환 (매개변수도 가능)
        animalSound(new Cat());//자동 타입변환 (매개변수도 가능) 
    }
        //자동 타입변환 : 추상클래스 타입 변수는 추상클래스를 상속받은 실체클래스의 타입으로 자동 타입변환이 된다. 
        private static void animalSound(Animal animal) { animal.sound();}}
```

**출력결과**

\------------------------------------------------

**왈왈!**
**야옹**
**왈왈!**
**야옹**
**왈왈!**
**야옹**

\------------------------------------------------


자, 이제 추상클래스와 추상클래스를 상속받아 구현한 실체클래스를 어떻게 객체생성을하고 사용하는지 예제를 봅시다!!

dog, cat 객체는 각 실체클래스가 구현한 sound()메서드가 실행된다 따라서, 왈왈! 야옹 이라는 다른결과를 도출합니다.

 

**또한, 추상클래스 변수에, 추상클래스를 상속받아 구현한 실체클래스 인스턴스를 주입하면 해당 추상클래스 변수는 자동 타입변환을 발생시켜 실체클래스 인스턴스처럼 사용할 수 있습니다.** 이를 **타입의 다형성**이라고 한다. 타입의 다형성은 **animalSound 라는 메서드를 통해 매개변수도 타입의 다형성(자동 타입변환)을 보여줄 수 있음을 확인할 수 있습니다.**

오늘도 너무나도 긴 글 읽어주셔서 감사합니다!!



