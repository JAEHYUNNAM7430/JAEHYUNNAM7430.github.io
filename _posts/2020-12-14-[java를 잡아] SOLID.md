---
title: "[java를 잡아] 객체지향의 특성들"
excerpt: "쉽게 외우자 SOLID"
categories:
  - java
tags:
  - java
---
## 1. 객체 지향 설계

안녕하세요. ! MONKEY.D 입니다 :-) 

이번 시간은 객체지향의 4대특성인 

- 캡슐화
- 상속
- 다형성
- 추상화

를 이용하여 객체 지향 설계를 올바르게 할수있도록 도와주는 원칙을 알아볼겁니다! <u>실무에서도 매우 중요한 원칙들이며, 객체 지향을 공부해봤고, 객체 지향으로 프로그래밍을 하려면 반드시 알아야 하는 중요한 원칙입니다.</u>  그럼 시작! 



객체지향 4대 특성인 상속, 캡슐화, 다형성, 추상화를 잘 알고 잘 다룬다고 해서 설계를 잘하는 것은 아닙니다. 

물론 4대 특성을 잘 살리면 설계가 탄탄해집니다. 하지만 설계 원칙이라는게 엄연히 존재하며, 중요하기 때문에 각 원칙의 맨 앞 알파벳만 따와 " SOLID " 라고 하지 않았을까요??



SOLID 원칙들은 자기 자신 클래스 안에 응집도는 내부적으로 높이고, 타 클래스들 간 결합도는 낮추는 High Cohesion-Loose Coupling 원칙을 객체 지향의 관점에서 도입한 것입니다.

왜 그랬을까요!? 간단합니다. 좋은 소프트웨어는 특징들은 응집도는 높고, 결합도는 낮기 때문입니다.

결국에는 모듈 또는 클래스 당 하나의 책임을 주어 더욱 더 독립된 모듈(클래스)을 만들기 위함입니다.

이렇게 설계된 **소프트웨어는 재사용이 많아지고, 수정이 최소화 되기 때문에 결국 유지 보수가 용이해집니다.** 



자 그럼 객체 지향 설계 5대 원칙이 각각 무엇인지 아래를 봅시다!

- **<u>S</u>RP (Single Responsibility Principle) 단일 책임 원칙**
- **<u>O</u>CP (Open Closed Principle) 개방 폐쇄 원칙**
- **<u>L</u>SP (Liskov Substitution Principle) 리스코프 치환 원칙**
- **<u>I</u>SP (Interface Segregation Principle) 인터페이스 분리 원칙**
- **<u>D</u>IP (Dependency Inversion Principle) 의존성 역전의 원칙**



**1. SRP (Single Responsibility Principle) 단일 책임 원칙**

- 객체는 단 하나의 책임만을 가져야 합니다.
- 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 하며(책임 = 변경 사유) 가은 이유로 변화하는 것끼리 묶고, 다른 이유로 변화하는 것 끼리는 분리합니다.

![7](https://user-images.githubusercontent.com/74045426/103232196-27a81a80-497d-11eb-8e0d-60277ff7cda4.JPG)

1. 단일 책임 원칙에서 '책임'의 기본 단위는 객체를 의미합니다. 즉, 객체는 단 하나의 책임만 가져야 한다는 의미입니다. 여기서 '책임'은 '해야 하는 것' , '할 수 있는 것' , '해야 하는 것을 잘할 수 있는 것' 으로 간주할 수 있습니다.

2. 객체에 책임을 할당할 때는 어떤 객체보다도 해당 작업을 잘할 수 있는 객체에 책임을 할당해야 하며 또 한 객체는 책임에 수반되는 모든 일을 자신만이 수행할 수 있어야 합니다.
3. 책임을 많이 질수록, 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합 될 가능성이 높습니다. 때문에 나쁜 설계로 이어집니다.



**2. OCP(Open-Closed Principle) 개방 폐쇄 원칙**

![6](https://user-images.githubusercontent.com/74045426/103232195-270f8400-497d-11eb-818c-41497a8ec485.JPG)

- 기존의 코드를 변경하지 않으면서(Closed) 기능을 추가(Open)할 수 있어야 합니다. 소프트웨어 엔티티가 확장에 대해서는 개방(Open)되어야 하지만, 변경에 대해서는 폐쇄(Closed)되어야 합니다. 클래스 자체를 변경하지 않고도(Closed) 그 클래스를 둘러싼 환경을 바꿀 수 있어야 합니다.
- OCP를 위반하지 않는 설계를 위해서는 무엇이 변하는 것인지, 무엇이 변하지 않는 것인지를 구분해야 합니다. 변해야 하는 것은 쉽게 변할 수 있게 하며, 변하지 않아야 할 것은 변하는 것에 의해 영향을 받지 않게 해야 합니다.

![5](https://user-images.githubusercontent.com/74045426/103232193-270f8400-497d-11eb-9672-097b7ca3a353.JPG)

- 위의 설계에서 SomeClient는 성적표나 출석부와 관련된 기능을 사용하고 있습니다. 만약 여기서 도서관 대여 명부와 관련된 기능을 추가하는 경우라면 어떻게 해야 할까요?
- '도서관 대여 명부' 클래스를 만들어서 SomeClient가 이 기능을 이용하도록 할 수도 있으나, 이 방식은 OCP를 위반합니다.
- 새로운 기능을 추가하기 위해 SomeClient 클래스를 수정해야 하기 때문입니다. SomeClient 클래스는 변하지 않고, 도서관 대여 명부 클래스를 추가하는 부분만 변경되도록 해야 합니다. 결과는 다음과 같습니다.

![4](https://user-images.githubusercontent.com/74045426/103232192-2676ed80-497d-11eb-9670-173c778588fb.JPG)

- SomeClient가 개별적인 클래스를 처리하도록 하지 않고, 인터페이스에서 구체적인 출력 매체를 캡슐화해 처리하도록 합니다. 클래스를 변경하지 않고도(Closed) 그 클래스를 둘러싼 환경을 변경(Open)할 수 있는 설계가 되어야 한다는 관점 역시 OCP라고 볼 수 있습니다.



**3. LSP (Liskov Substitution Principle) 리스코프 치환 원칙**

![3](https://user-images.githubusercontent.com/74045426/103232191-25de5700-497d-11eb-8b93-707aea93c9ec.JPG)

- 리스코프 치환 원칙에 따르면 부모 클래스와 자식 클래스 사이의 행위가 일관성이 있어야 합니다.
- 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 대체해도 프로그램의 의미는 변화되지 않습니다. 서브타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 합니다.
- LSP를 만족하면, 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 대체해도 프로그램이 동일하게 수행됩니다. 이를 위해 부모 클래스와 자식 클래스의 행위는 일관적이어야 합니다. 달리 말하면, 자식 클래스를 사용할 때에도 특별히 뭔가 변경할 필요 없이 마치 부모 클래스를 사용하는 것처럼 그대로 사용할 수 있어야 한다는 것입니다.
- 자식 클래스가 부모 클래스 인스턴스의 행위를 일관성 있게 실행하는 가장 직접적이고직관적인 방법은, 부모 클래스에서 상속받는 메서드들이 자식 클래스에 오버라이드, 즉 재정의되지 않도록 하면 됩니다.



**4. ISP (Interface Segregation Principle) 인터페이스 분리 원칙**

![2](https://user-images.githubusercontent.com/74045426/103232189-25de5700-497d-11eb-9951-3f0dcaab0ca0.JPG)

- 인터페이스를 클라이언트에 특화되도록 ㅂㄴ리시키고 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 됩니다.
- ISP는 클라이언트 자신이 이용하지 않는 기능에는 영향을 받지 않아야 한다는 것입니다.



**5. DIP (Dependency Inversion Principle) 의존성 역전의 원칙**

![1](https://user-images.githubusercontent.com/74045426/103232187-24ad2a00-497d-11eb-8953-c4c24a44b2c5.JPG)

- 의존 관계를 맺을 때, 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것,  거의 변화가 없는 것에 의존하게 합니다. 자주 변경하는 구체 클래스 대신 인터페이스나 추상 클래스에 의존하도록 합니다.
- 변하기 어려운 것 : 정책, 전략과 같은 어떤 큰 흐름이나 개념 같은 추상적인 것->추상클래스, 인터페이스
- 변하기 쉬운 것 : 구체적인 방식, 사물 등
- 객체지향 관점에서는, 변하기 어려운 추상적인 것들을 표현하는 수단으로 추상클래스와 인터페이스가 있습니다. 추상클래스아 인터페이스는 보통 자신에게서 유도된 구체적인 클래스보다 덜 변합니다. 그러므로 DIP를 만족하려면, 어떤 클래스가 도움을 받을 때 구체적인 클래스보다는 추상적인 것(인터페이스나 추상클래스)와 의존 관계를 맺도록 설계해야 합니다. DIP를 만족하는 설계는 변화에 유연한 시스템이 됩니다.
- 만약 어떤 클래스에서 상속받아야 한다면, 부모 클래스를 추상 클래스로 만듭니다. 어떤 클래스의 참조를 가져야 한다면, 참조 대상이 되는 클래스를 추상 클래스로 만듭니다. 또, 어떤 메소드를 호출해야 한다면, 호출되는 메소드를 추상 메소드로 만듭니다.
- DIP랄 만족하면 의존성 주입을 통해 변화를 쉽게 수용할 수 있는 코드를 작성할 수 있습니다. 의존성 주입을 이용하면, 다음 코드와 같이 대상 객체를 변경하지 않고도 대상 객체의 외부 의존 객체를 바꿀 수 있습니다.

```java
public class Kid{
    private Toy toy; //Toy는 abstract, 즉 변하기 어려운 것이다.
    
    public void setToy(Toy toy){
        this.toy = toy;
    }
    
    public void play(){
        System.out.println(toy.toString());
    }
}
```

- 만약 Kid 객체와 의존 관계를 맺고 있는 Toy 객체를 다른 객체로 바꾸고 싶다면(원래는 Robot 객체였는데, Lego 객체로 바꾼다고 가정), Toy를 상속받는 또 다른 객체를 생성한 뒤 Kid의 setToy()를 통해 의존객체를 손쉽게 바꿀 수 있습니다.
- 그렇다면 Vector나 String은 모두 구체클래스이지만 사용한다 해서 DIP를 위반하는 것은 아닙니다. "의존하면 안되는 것은 '자주 변경되는' 구체 클래스이고, 앞으로 변하지 않을 구체 클래스에 의존 하는 것은 안전하다." Vector나 String은 앞으로 변경되지 않을 가능성이 높은 것이니 의존해도 문제가 없습니다.
- "의존하면 안되는 것은, '자주 변경되는' 클래스입니다." 지금 막 개발 중인 구체 클래스나, 변할 가능성이 높은 비즈니스 로직을 담은 클래스 같은 것들을 의미합니다. 이런 클래스의 인터페이스를 만든 다음, 이 인터페이스에 의존하게끔 하는 것이 바람직합니다.



오늘도 포스팅 읽어주셔서 감사드립니다! MONDEY.D 였습니다. :) 항상 건강 유의하시고 코로나 조심하세요!